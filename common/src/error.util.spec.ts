// tslint:disable no-unused-expression
import { expect } from 'chai';
import { SinonStub, stub } from 'sinon';

import { AppError }  from './app.error';
import { ErrorUtil } from './error.util';

describe('ErrorUtil', () => {

    describe('getCustomProperties', () => {

        it('returns any properties not defined on Error', () => {

            const error: any = { someCustomProp: 'foo', anotherCustomProp: 'bar', stack: 'hello' };
            expect(ErrorUtil.getCustomProperties(error)).to.include({ someCustomProp: 'foo', anotherCustomProp: 'bar' });

        });

    });

    describe('getLoggableError', () => {

        let getCustomProperties: SinonStub;
        let appErrorStack: SinonStub;

        beforeEach(() => {
            getCustomProperties = stub(ErrorUtil, 'getCustomProperties').returns({
                someCustomProp: 'foo',
                anotherCustomProp: 'bar',
            });
            appErrorStack = stub(AppError, 'stack').returns('stack!');
        });
        afterEach(() => {
            getCustomProperties.restore();
            appErrorStack.restore();
        });

        it('includes properties found by getCustomProperties', () => {

            const error: any = { message: 'message!' };
            expect(ErrorUtil.getLoggableError(error)).to.include({
                someCustomProp: 'foo',
                anotherCustomProp: 'bar',
            })

        });

        it('includes the stack generated by AppError.stack()', () => {

            const error: any = { message: 'message!' };
            expect(ErrorUtil.getLoggableError(error)).to.include({
                stack: 'stack!',
            });
            expect(AppError.stack).to.have.been
                .calledOnce
                .calledWith(error);

        });

    });

    describe('logEventError', () => {

        let getLoggableError: SinonStub;
        let consoleError: SinonStub;

        beforeEach(() => {
            getLoggableError = stub(ErrorUtil, 'getLoggableError').returns({
                someCustomProp: 'foo',
                anotherCustomProp: 'bar',
            });
            consoleError = stub(console, 'error');
        });
        afterEach(() => {
            getLoggableError.restore();
            consoleError.restore();
        });

        it('calls console.error with the source, message, event, and output of getLoggableError', () => {

            const error: any = { message: 'message!' };
            ErrorUtil.logEventError('test', 'this is a test', 'a test', error);

            expect(console.error).to.have.been
                .calledOnce
                .calledWithExactly('[test] this is a test', {
                    error: {
                        someCustomProp: 'foo',
                        anotherCustomProp: 'bar',
                    },
                    event: 'a test',
                });

        });

    });

});
